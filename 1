import math
import argparse
import numpy as np
import os
from define_flow import define_flow_direction
from define_flow import read_cut
from define_flow import read_minpos
from define_flow import pos_pot
#from pyemma.msm import MSM
from define_cross import define_cross
from get_pos import get_pos
from fpt_ana import  first_passage#(start, end, T, length):
from fct_markov import mfpt_markov
from fct_markov import calc_Sprod
from fct_markov import analyse_MSM
from fct_markov import hist_to_cumhist
from fct_markov import calc_Caliber
from fct_markov import define_pathE
from fct_markov import calc_av
from fct_markov import moment_distribution


from scipy import optimize

import random

def equ(c,ms,W):
	tup = [ (sum([W[j,k] *c[k]*c[j] for k in range(ms)] )-1.0) for j in range(ms)]
	tup = tuple(tup)
	return tup

def reweight(T, ms, Sprod, Sprod_in):

#	W = [ [  T[i,j] * math.exp(gamma/2.*(r[i,j]+r[j,i]) + (Sprod[i,j]-Sprod_in[i,j])/2. ) for j in range(ms)] for i in range(ms)]
	W = [ [  np.sqrt(T[i,j] *T[j,i]) * math.exp( Sprod[i,j]/2. ) for j in range(ms)] for i in range(ms)]
	W = np.asarray(np.real(W))

	Omega = np.zeros((ms,ms))

	Ev,Evecl = np.linalg.eig(np.transpose(W))
	idx = Ev.argsort()[::-1] 
	Ev = Ev[idx]  #order eigenvectors by size
	Evecl = np.transpose(Evecl)
	Evecl = Evecl[idx,:] 
	Ev,Evecr = np.linalg.eig(W)
	idx = Ev.argsort()[::-1] 
	Ev = Ev[idx]  #order eigenvectors by size
	Evecr = np.transpose(Evecr)
	Evecr = Evecr[idx,:] 
	c = np.abs(np.real(Evecr[0,:]))

	c = np.ones(ms);

#	copt = fsolve(equ,c,args=(ms,W,),xtol=1e-10) # should converge for any starting point
	copt = optimize.least_squares(equ, c,args=(ms,W,), bounds=([0.]*ms, 1.))

	copt= copt.x
	k = [[copt[j] *copt[i] *W[i,j] for j in range(ms)] for i in range(ms)]
	k= np.asarray(k)

	for i in range(ms): # minimal correction from numerics, eta = 1.
		norm = sum(k[i,:])
		k[i,:] = k[i,:] / norm
	
	Ev,Evec =  analyse_MSM(k)
	p = np.real(Evec[0] / sum(Evec[0]) )
	J = calc_av(r,k,p)
	J_err =  np.abs(J - J_comp)

	for i in range(ms):
		for j in range(ms):
			Omega[i,j] = T[i,j] * T[j,i] * copt[j] *copt[i]
	
	norm = sum(Omega[:,:])
	Omega = Omega / norm
	


	return Omega, np.real(k),copt

def equ_pij(c,ms,A,w):
	tup = [ (sum([A[j,k] * (c[j]**w[k,j]) * (c[k]**w[j,k]) for k in range(ms)] )-1.0) for j in range(ms)]
	tup = tuple(tup)
	return tup


def reweight_pij(T, ms, Sprod, Sprod_in): # reweight without global balance
	w = [ [  1./(1+np.exp(Sprod[i,j])) for j in range(ms)] for i in range(ms)]
#	w = [ [  1./2. for j in range(ms)] for i in range(ms)]
	w = np.asarray(np.real(w))
	A = [ [  T[i,j]**w[j,i] * T[j,i]**w[i,j] * math.exp( 1. + w[i,j]*(Sprod[i,j]) ) for j in range(ms)] for i in range(ms)]
	A = np.asarray(np.real(A))

	Omega = np.zeros((ms,ms))

	c = np.ones(ms);

	copt = optimize.fsolve(equ_pij,c,args=(ms,A,w),xtol=1e-12) # should converge for any starting point
	k = [[copt[i]**w[j,i] * copt[j]**w[i,j] *A[i,j] for j in range(ms)] for i in range(ms)]
	k= np.asarray(k)

	for i in range(ms): # minimal correction from numerics, eta = 1.
		norm = sum(k[i,:])
		k[i,:] = k[i,:] / norm
	
	Ev,Evec =  analyse_MSM(k)
	p = np.real(Evec[0] / sum(Evec[0]) )
	J = calc_av(r,k,p)
	J_err =  np.abs(J - J_comp)
	

	return k,copt

def iterate(m,k,W,w,Sprod, Sprod_in):
	A = np.zeros((ms,ms))
	a = np.zeros(ms)
	Phi_n = np.zeros(ms)	
	Psi_n = np.zeros(ms)	
	Phi = np.exp(m)

	for i in  range(ms):
		a[i] = -1.
		A[i,i] = -1.
		for j in range(ms):
			temp = k[i,j] * w[i,j]
			A[i,j] += temp
			A[i,i] -= temp
			a[i] -= temp * (Sprod[i,j] - Sprod_in[i,j])
	
	invA = np.linalg.inv(A)
	B = 2*invA + np.eye(ms)
	b = -invA.dot(a)

	n = B.dot(m) + b	
#	m = optimize.least_squares(equ_new, m,args=(ms,W,w,n), bounds=([0.]*ms, 1000.)).x
	Psi_n = np.exp(n)
	Psi = np.exp(n)
	
	for i in range(ms):
		Phi_n[i] = 1./ ( ( sum( W[i,j] * (Phi[i]*Phi[j]*Psi[i])**(w[i,j]) * Psi[j]**(w[j,i])   for j in range(ms) ))**2 )
			#mistake?????
	m= np.log(Phi_n)
	#n = np.log(Psi_n)

	k = [ [ W[i,j]*np.exp(w[j,i] *(m[i]+n[j] )  +w[i,j] * (m[j] + n[i] )  ) for j in range(ms) ] for i in range(ms)]	
	k = np.asarray(k)

	return m,k

def equ_full(x,ms,A,w,Sprod,Sprod_in):
	# x[0:ms] n 
	# x[ms:2ms] m 
	tup1 = [ -2. *np.log(sum([A[i,k] * np.exp((x[k]+x[ms+i])*w[k,i] + (x[ms+k]+x[i] )*w[i,k] - w[i,i] *x[i]  )   for k in range(ms)] )) for i in range(ms)]
	tup1 = tuple(tup1) #n
	tup2 = [ -1 - x[i] - sum( w[i,k] *(Sprod[i,k] -Sprod_in[i,k] - x[ms+i] +x[ms+k] -x[k] + x[i] ) * A[i,k] * np.exp((x[k]+x[ms+i])*w[k,i] + (x[i]+x[ms+k] )*w[i,k] ) for k in range(ms)) for i in range(ms)]
	tup2 = tuple(tup2) #m
	tup = tup1+tup2
	print(tup[0] , tup[30])
	return tup



def reweight_selfit(T, ms, Sprod,Sprod_in,delta_min):
	w = [ [  1./(1+np.exp(Sprod[i,j])) for j in range(ms)] for i in range(ms)]
	w = np.asarray(np.real(w))


	weight = 0.95 

	W = np.zeros((ms,ms))
#	Sprod_in = np.zeros((ms,ms))
	cutoff = 0.001
	for i in range(ms):
		for j in range(ms):
			W[i,j] = T[i,j]**w[j,i] * T[j,i]**w[i,j] *np.exp(w[i,j] * Sprod[i,j])	
#			if (T[i,j]> cutoff and T[j,i] >cutoff):
#				Sprod_in[i,j] = np.log(T[i,j] / T[j,i])

	
	Omega,k,m= reweight(T, ms, Sprod, Sprod_in);
 
	A = np.zeros((ms,ms))
	a = np.zeros(ms)
	for i in  range(ms):
		a[i] = -1.
		A[i,i] = -1.
		for j in range(ms):
			temp = k[i,j] * w[i,j]
			A[i,j] += temp
			A[i,i] -= temp
			a[i] -= temp * (Sprod[i,j] - Sprod_in[i,j])
	
	invA = np.linalg.inv(A)
	B = 2*invA + np.eye(ms)
	b = -invA.dot(a)

	n = B.dot(m) + b	
	m = optimize.least_squares(equ_new, m,args=(ms,W,w,n), bounds=([0.]*ms, 1000.)).x
	

	k_cur = k.copy()
	m_cur = m.copy()
	n_cur = n.copy()
	it =0

	x = np.zeros(2*ms)
	x[0:ms] = n[:]
	x[ms:] = m[:]
	#x=optimize.fsolve(equ_full, x,args=(ms,W,w,Sprod,Sprod_in))
#	print(x)
	#while (   > delta_min ):
	x_cur= np.zeros(2*ms)
	while(it < 200):
		print(it)
		delta = np.max(x_cur) 
		x_cur = x_cur - delta
			
		x = tuple(x_cur)
		x  = equ_full(x,ms,W,w,Sprod,Sprod_in)		
	#	m_cur = weight * m_cur + (1-weight) *m
	#	n_cur = weight * n_cur + (1-weight) *n
		x_cur = weight * x_cur + (1-weight) *np.asarray(x)
		it +=1
		
		print("m", x[32])
		print("n", x[2])
		print("\n")
#
			
		#print(it, delta, m[0] + n[0] , w[1,0]*(m_cur[0]+n_cur[1]) + w[0,1]*(m_cur[1]+n_cur[0]) )	
	
#	print(it,weight, delta_min, delta)
	
	n[:] = x_cur[0:ms]
	m[:] = x_cur[ms:]
	print(n)
	print(m)
	k = [ [ W[i,j]*np.exp(w[j,i] *(m[i]+n[j] )  +w[i,j] * (m[j] + n[i] )  ) for j in range(ms) ] for i in range(ms)]	
	k= np.asarray(k)
#

	print(sum(k[0,:]))
	print(sum(k[15,:]))
	print(sum(k[29,:]))
	print(-m[0] - n[0] -sum( w[0,j] * k[0,j]*(Sprod[0,j] - Sprod_in[0,j] -m[0] +m[j] -n[j] +n[0])  for j in range(ms)) )
	print(-m[20] - n[20] -sum( w[20,j] * k[20,j]*(Sprod[20,j] - Sprod_in[20,j] -m[20] +m[j] -n[j] +n[20])  for j in range(ms)) )
	print(-m[10] - n[10] -sum( w[10,j] * k[10,j]*(Sprod[10,j] - Sprod_in[10,j] -m[10] +m[j] -n[j] +n[10])  for j in range(ms)) )
	for i in range(ms): # minimal correction from numerics, eta  =1 ?
		norm = sum(k[i,:])
		#print(norm)
		k[i,:] = k[i,:] / norm
#	print("m", m)
#	print("n", n)
	
	#influence of Sprod_in? 
#	Invariant = [ [ T[i,j] *T[j,i] * np.exp(w[i,j]/2. *(Sprod[i,j] - Sprod_in[i,j]) +w[j,i]/2.*(Sprod[j,i] - Sprod[i,j])+w[i,j]*(m[j]+n[i])+w[j,i]*(m[i]+n[j]) ) for j in range(ms)] for i in range(ms)]
#	Invariant = np.asarray(Invariant)	
	
#	Invariant = Invariant / sum(Invariant)

	Invariant = np.zeros(ms)
	Ev,Evec =  analyse_MSM(k)
	p = np.real(Evec[0] / sum(Evec[0]) )
	J = calc_av(r,k,p)


	return Invariant,np.real(k),np.real(p)



def equ_new(m,ms,W,w,n):
	tup = [ (sum(W[i,j]*np.exp(w[j,i] *(m[i]+n[j] )  +w[i,j] * (m[j] + n[i] )  ) for j in range(ms)) -1.0) for i in range(ms)]	
	tup = tuple(tup)
	return tup


parser = argparse.ArgumentParser()
parser.add_argument('-o', help='reweight to ident')
parser.add_argument('-i', help='reweight from ident')
parser.add_argument('-l', help='choose lagtime of T')
parser.add_argument('-rc', help='rancut for size of FPT well')
parser.add_argument('-a', help='rescaling for \delta x',default=1.0)
parser.add_argument('-d', help='exit condition for iteration',default=1e-05)
args = parser.parse_args();
ident = args.o
identin = args.i
rancut = int(args.rc)
lag = args.l
mul = float(args.a)
delta_min = float(args.d)


path = "/data/isilon/bause/single_particle/"+str(lag)+"/T/T_"+str(identin) +".dat"
T = np.loadtxt(path)
ms = np.shape(T)[0]
for i in range(ms):
	for j in range(ms):
		if (T[i,j]  > 0. ):
			T[i,j] = T[i,j] / sum(T[i,:])
		else:
			T[i,j] = 0.


path0 = "/data/isilon/bause/"
ms,cut = read_cut(path0,ident)
ms, minpos = read_minpos(path0,ident)
r = define_flow_direction(ms,cut)


#T = np.loadtxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/T/Topt_"+str(identin)+".dat")
#T_comp = np.loadtxt("/data/isilon/bause/single_particle/"+str(lag)+"/T/T_"+str(ident)+".dat")

for line in open("/data/isilon/bause/single_particle/param_"+str(ident)+".dat","r"):
	cont = line.split()
	if(cont[0] == 'dT'):
		dT = float(cont[1])
	if(cont[0] == 'T0'):
		temperature = float(cont[1])
	if(cont[0] == 'extf'):
		force = int(cont[1])
	if(cont[0] == 'T'):
		temperature = float(cont[1])

for line in open("/data/isilon/bause/single_particle/param_"+str(identin)+".dat","r"):
	cont = line.split()
	if(cont[0] == 'dT'):
		dT_in = float(cont[1])
	if(cont[0] == 'T0'):
		temperature_in = float(cont[1])
	if(cont[0] == 'extf'):
		force_in = int(cont[1])
	if(cont[0] == 'T'):
		temperature_in = float(cont[1])




potential = np.loadtxt("/data/isilon/bause/single_particle/potential_ms_"+str(ident)+".dat")
potential_in = np.loadtxt("/data/isilon/bause/single_particle/potential_ms_"+str(identin)+".dat")
path = "/data/isilon/bause/single_particle/"+str(lag)+"/T/T_"+ str(ident) +".dat"
T_comp = np.loadtxt(path)
ms = np.shape(T_comp)[0]
for i in range(ms):
	for j in range(ms):
		if (T_comp[i,j] > 0. ):
			T_comp[i,j] = T_comp[i,j] / sum(T_comp[i,:])
		else:
			T_comp[i,j] = 0.


Ev,Evec =  analyse_MSM(T_comp)

p_comp = np.real(Evec[0] / sum(Evec[0]) )
temp = np.loadtxt("/data/isilon/bause/single_particle/potential_ms_"+str(ident)+".dat")
E = np.zeros((ms,ms))
 

for i in range(ms):
	for j in range(ms):
		E[i,j] = np.exp(  (temp[i,1] + temp[j,1]) / (2. * temperature) )


lvl = len(minpos)
Ng = 800
gamma = np.zeros(Ng)
MFPT_ar = np.zeros((Ng, lvl *lvl))
ratio = np.zeros((Ng,3))

J_ar = np.zeros(Ng)

MFPT_comp = mfpt_markov(T_comp , minpos, rancut, ms,lvl).reshape(lvl*lvl)
ratio_comp =  sum( [MFPT_comp[1]/MFPT_comp[3] , MFPT_comp[6]/MFPT_comp[2] , MFPT_comp[5]/MFPT_comp[7]] ) / 3.
J_comp =  calc_av(r, T_comp, p_comp)


Sprod_comp = calc_Sprod(T_comp)
Eav_comp = calc_av(E,T_comp,p_comp)

#ratio_cur = 10
J_cur = 0
J_err = 100

Jdiff = 1.
Jdiff_min = 0.00001

sp = np.zeros((ms,ms))
sp_in = np.zeros((ms,ms))

for k in range(ms):
	for l in range(ms):
		if (np.abs(k-l) < (ms/2)):
				sp[k,l] = ( -force / ms * (k-l)*mul+ potential[k,1] - potential[l,1] ) / temperature
				sp_in[k,l] = ( -force_in / ms * (k-l)*mul+ potential_in[k,1] - potential_in[l,1] ) / temperature_in
		elif (l>k):
				sp[k,l] = ( -force / ms * (ms-l+k)*mul+ potential[k,1] - potential[l,1] ) / temperature
				sp_in[k,l] = ( -force_in / ms * (ms-l+k)*mul+ potential_in[k,1] - potential_in[l,1] ) / temperature_in
		else:
				sp[k,l] = ( force / ms * (ms-k+l)*mul+ potential[k,1] - potential[l,1] ) / temperature
				sp_in[k,l] = (force_in / ms * (ms-k+l)*mul+ potential_in[k,1] - potential_in[l,1] ) / temperature_in
#print( "real",p_comp)
#gamma_cur = fmin(reweight_min,x0=0.0,ftol = Jdiff_min , disp=False, args=(T ,r,E , ms , J_comp, sp, sp_in))
#gamma_cur = gamma_cur[0]


#for i in range(3):
#	gamma_cur = i * -0.01
#	J_err,T_cur,p_cur = reweight(gamma_cur,T ,r , ms , J_comp, sp)
#	print(gamma_cur,J_err)

gamma_cur =0


Omega,T_cur, p_cur = reweight_selfit(T,ms,sp,sp_in,delta_min)

J_cur = calc_av(r,T_cur,p_cur)

np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/T/p_"+str(identin)+"_"+str(ident)+".dat",p_cur)

np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/T/Invariant_"+str(identin)+"_"+str(ident)+".dat",Omega)
#np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/T/Invariantn_"+str(identin)+"_"+str(ident)+".dat",E/sum(E))


Sprod_rew = calc_Sprod(T_cur)
MFPT_rew = mfpt_markov(T_cur , minpos, rancut, ms,lvl).reshape(lvl*lvl)
ratio_rew =  np.sum([MFPT_rew[1]/MFPT_rew[3] , MFPT_rew[6]/MFPT_rew[2] , MFPT_rew[5]/MFPT_rew[7]]) / 3.
Eav_rew = calc_av(E, T_cur, p_cur)


#ratio_comp = sum(np.abs([MFPT_comp[1]/MFPT_comp[3] , MFPT_comp[6]/MFPT_comp[2] , MFPT_comp[5]/MFPT_comp[7] ] ))
#print(calc_Caliber(T_cur,p_cur,T,J_comp,r,ms,gamma_cur))


length = 400

MFPT_hist = np.zeros((lvl*lvl*3,length))
mom_cur = np.zeros((lvl*lvl,3))
mom_comp = np.zeros((lvl*lvl,3))
mom_start = np.zeros((lvl*lvl,3))
for i in range(lvl):
	for j in range(lvl):
		if (i != j):
			start = list(range(minpos[i]-rancut, minpos[i]+rancut+1))
			end = list(range(minpos[j]-rancut, minpos[j]+rancut+1))
			MFPT_hist[i*lvl+j] = first_passage(start, end, T_cur, length)
			MFPT_hist[i*lvl+j+   lvl*lvl] = first_passage(start,end, T_comp, length)
			MFPT_hist[i*lvl+j+ 2*lvl*lvl] = first_passage(start,end, T, length)
			for k in range(1,4):
				mom_cur[i*lvl+j,k-1] = moment_distribution(k,MFPT_hist[i*lvl+j])
				mom_comp[i*lvl+j,k-1] = moment_distribution(k,MFPT_hist[i*lvl+j+lvl*lvl])
				mom_start[i*lvl+j,k-1] = moment_distribution(k,MFPT_hist[i*lvl+j+2*lvl*lvl])

			mom_cur[i*lvl+j,1] = np.sqrt( mom_cur[i*lvl+j,1] - mom_cur[i*lvl+j,0]* mom_cur[i*lvl+j,0] ) #standard deviation
			mom_cur[i*lvl+j,2] = (mom_cur[i*lvl+j,2] - 3.*mom_cur[i*lvl+j,0] * mom_cur[i*lvl+j,1] *mom_cur[i*lvl+j,1]  - mom_cur[i*lvl+j,0]* mom_cur[i*lvl+j,0]* mom_cur[i*lvl+j,0])/ (mom_cur[i*lvl+j,1] * mom_cur[i*lvl+j,1] * mom_cur[i*lvl+j,1] ) #skewness

			mom_comp[i*lvl+j,1] = np.sqrt( mom_comp[i*lvl+j,1] - mom_comp[i*lvl+j,0]* mom_comp[i*lvl+j,0] ) #standard deviation
			mom_comp[i*lvl+j,2] = (mom_comp[i*lvl+j,2] - 3.*mom_comp[i*lvl+j,0] * mom_comp[i*lvl+j,1] *mom_comp[i*lvl+j,1]  - mom_comp[i*lvl+j,0]* mom_comp[i*lvl+j,0]* mom_comp[i*lvl+j,0])/ (mom_comp[i*lvl+j,1] * mom_comp[i*lvl+j,1] * mom_comp[i*lvl+j,1] ) #skewness




for k in range(1,4):
	np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/MFPT/moment"+str(int(k))+"_"+str(identin)+"_"+str(ident)+".dat",mom_cur[:,k-1].reshape((lvl,lvl)))
	np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/MFPT/moment"+str(int(k))+"_"+str(ident)+".dat",mom_comp[:,k-1].reshape((lvl,lvl)))

#
#with open("/data/isilon/bause/single_particle/"+str(lag)+"/Sprod_compo_"+str(identin)+".dat", 'ab') as f:
##with open("/data/isilon/bause/single_particle/"+str(lag)+"/Sprod_comp.dat", 'ab') as f:
#	out = np.zeros(4)
#	out[0] = identin
#	out[1] = ident
#	out[2] = Sprod_comp
#	out[3] = Sprod_rew
#	np.savetxt(f,[out])
#
#with open("/data/isilon/bause/single_particle/"+str(lag)+"/moment1_compo_"+str(identin)+".dat", 'ab') as f:
##with open("/data/isilon/bause/single_particle/"+str(lag)+"/moment1_comp.dat", 'ab') as f:
#	out = np.zeros(2+lvl*lvl*2)
#	out[0] = identin
#	out[1] = ident
#	out[2:lvl*lvl+2] = mom_comp[:,0]
#	out[lvl*lvl+2:] = mom_cur[:,0]
#	np.savetxt(f,[out])
#
#
#with open("/data/isilon/bause/single_particle/"+str(lag)+"/moment2_compo_"+str(identin)+".dat", 'ab') as f:
##with open("/data/isilon/bause/single_particle/"+str(lag)+"/moment2_comp.dat", 'ab') as f:
#	out = np.zeros(2+lvl*lvl*2)
#	out[0] = identin
#	out[1] = ident
#	out[2:lvl*lvl+2] = mom_comp[:,1]
#	out[lvl*lvl+2:] = mom_cur[:,1]
#	np.savetxt(f,[out])
#
#with open("/data/isilon/bause/single_particle/"+str(lag)+"/moment3_compo_"+str(identin)+".dat", 'ab') as f:
##with open("/data/isilon/bause/single_particle/"+str(lag)+"/moment3_comp.dat", 'ab') as f:
#	out = np.zeros(2+lvl*lvl*2)
#	out[0] = identin
#	out[1] = ident
#	out[2:lvl*lvl+2] = mom_comp[:,2]
#	out[lvl*lvl+2:] = mom_cur[:,2]
#	np.savetxt(f,[out])
#

#f = open("/data/isilon/bause/single_particle/"+str(lag)+"/MFPT1_comp.dat", 'a')
#np.savetxt(f,np.array([int(identin),int(ident),mom_comp[1],momrew[1]]))

ratio_t = np.zeros((ms,ms))
cutoff = 0.0000001
for k in range(ms):
	for l in range(ms):
		if (T_cur[k,l] > cutoff and T_cur[l,k] > cutoff):
			ratio_t[k,l] = np.log( T_cur[k,l] / T_cur[l,k] )
	
np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/T/ratio_"+str(identin)+"_"+str(ident)+".dat",ratio_t)
np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/T/ratio_th_"+str(identin)+"_"+str(ident)+".dat",sp)
#np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/T/ratio_diffS_"+str(identin)+"_"+str(ident)+".dat",np.abs(sp-ratio_t))



print(identin, ident,J_comp,J_cur, Sprod_comp, Sprod_rew, mom_comp[1,0], mom_cur[1,0], mom_comp[3,0], mom_cur[3,0] )


MFPT_cumhist = hist_to_cumhist(MFPT_hist)
#print(identin, ident,gamma_cur, tot_error)
np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/MFPT/hist_"+str(identin)+"_"+str(ident)+".dat", np.transpose(MFPT_hist))
np.savetxt("/data/isilon/bause/single_particle/"+str(lag)+"/reweight/T/T_"+str(identin)+"_"+str(ident)+".dat", T_cur)

	





