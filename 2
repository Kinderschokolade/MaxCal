import numpy as np
import math
import functools
from scipy.optimize import minimize
from scipy.sparse.linalg.eigen.arpack import eigs
from random import randint, uniform, seed
from operator import add
from scipy.optimize import basinhopping
from scipy.optimize import OptimizeResult
from scipy.optimize import fmin_slsqp
import time

def frompos(x):
	return{
		0:0,1:0,2:0,9:0,10:0,
		3:1,4:1,5:1,11:1,12:1,
		6:2,7:2,8:2,13:2,14:2,
	}[x]

def topos(x):
	return{
		0:[0,1,2,9,10],
		0:[3,4,5,11,12],
		0:[6,7,8,13,14],
	}[x]


def custmin(likeli, x0,constraints, bounds, args=(), maxfev=None, stepsize=1e-5, maxiter=5000, callback=None, **options):
	improved = True
	stop = False
	eps = 1e-6		

	newcons = [None]*6
	newcons[0:3] = constraints[0:3]

	if (math.isclose(x0[9],eps)):
		newcons[3] = lambda x: x[9]
	else:
		newcons[3] = lambda x: x[11]

	if (math.isclose(x0[10],eps)):
		newcons[4] = lambda x: x[10]
	else:
		newcons[4] = lambda x: x[13]

	if (math.isclose(x0[12],eps)):
		newcons[5] = lambda x: x[12]
	else:
		newcons[5] = lambda x: x[14]
	
	out,fx,its,imode,smode = fmin_slsqp(likeli ,x0 ,eqcons=newcons ,bounds=bounds ,full_output=True ,iter = maxiter, acc = 1e-03)
	print(out)
	return OptimizeResult(fun=fx, x=out, nit=its,
			nfev=its, success=imode) #nfev not correct this way


def complete_rates(x):
	xfull = np.zeros(18)
	xfull[0:9] = x[0:9]
	xfull[10:13] = x[9:12]
	xfull[14:17] = x[12:15]
	return xfull

def reduce_rates(x):
	xred = np.zeros(15)
	xred[0:9] = x[0:9]
	xred[9:12] = x[10:13]
	xred[12:15] = x[14:17]
	return xred


def likel(xin,sign,c, n, gamma,m):
	x = complete_rates(xin)
	#print(x)
	k = [a+b for a,b in zip(x[0:9],x[9:18])]	
	k = np.asarray(k).reshape(3,3)
	k = np.transpose(k)
	Ev, Evec = eigs(k, k=1)
	#print(k,Ev)
	p = (np.squeeze(Evec) / np.squeeze(Evec).sum()).real
#	print(sum(c[i]*math.log(x[i]+x[i+9]) for i in range(9)) 
#	,-sum(n[j] * math.fabs( sum( p[i]*(x[i*3+j]+x[i*3+j+9]) 
#		for i in range(0,3) )-p[j] ) for j in range(3)) 
#	,-sum(gamma[i*3+j] *math.fabs(p[i]*x[i*3+j] - p[j]*x[j*3+i]) 
#		for i in range(0,3) for j in range(0,3))
#	,-sum(math.pow(m[j]*(sum(x[i+j*3] + x[i+j*3+9] for i in range(3)) -  1),2)
#		for j in range(3) ))
#print(K, p[2]*(x[6]+x[15]) - p[0] *(x[2]+x[11]))
#	print(x.reshape(6,3))
#	print("test",sum(c[i]*math.log(x[i]+x[i+9]) for i in range(9)) 
#	,-sum(n[j] * math.pow( sum( p[i]*(x[i*3+j]+x[i*3+j+9]) 
#		for i in range(0,3) )-p[j] ,2) for j in range(3)) 
#	,-sum(gamma[i*3+j] *math.pow(p[i]*x[i*3+j] - p[j]*x[j*3+i],2) 
#		for i in range(0,3) for j in range(0,3)))
#	print(k,p)
#	print(x.reshape(6,3))	
#	print(
#		sum(x[i]+x[i+9] for i in range(3)),
#		sum(x[i+3]+x[i+12] for i in range(3)),
##		sum(x[i+6]+x[i+15] for i in range(3)),
#	)	
	return (sign*( 
	sum(c[i]*math.log(x[i]+x[i+9]) for i in range(9)) 
	- sum(n[j] * math.fabs(sum( p[i]*(x[i*3+j]+x[i*3+j+9]) 
		for i in range(0,3) )-p[j]) for j in range(3))
	- sum( gamma[i*3+j] *math.fabs(p[i]*x[i*3+j] - p[j]*x[j*3+i]) 
		for i in range(0,3) for j in range(0,3))
	- sum(math.pow(m[j]*(sum(x[i+j*3] + x[i+j*3+9] for i in range(3)) -  1),2)
		for j in range(3) )
	))
	#loglikelihood fct + stationary state cond + detailed balance(for k's)

def likel_deriv(x, sign=1.0):
	""" Derivative of objective function """
	dfdx0 = sign*(-2*x[0] + 2*x[1] + 2)
	dfdx1 = sign*(2*x[0] - 4*x[1])
	return np.array([ dfdx0, dfdx1 ])
# does not work for now, derivative does not exist

#cons = (
#{'type': 'eq','fun' : 
#lambda x: sum(x[i+0] for i in range(3)) +x[9]+x[10] -  1},
#{'type': 'eq','fun' : 
#lambda x: sum(x[i+3] for i in range(3))+x[11]+x[12] -  1},
#{'type': 'eq','fun' : 
#lambda x: sum(x[i+6] for i in range(3))+x[13]+x[14] -  1},
#{'type': 'eq','fun' :lambda x: np.amin([x[9],x[11]])},
#{'type': 'eq','fun' :lambda x: np.amin([x[12],x[14]])},
#{'type': 'eq','fun' :lambda x: np.amin([x[13],x[10]])},
#)
	#also the derivative part becomes complicated

def accept_test(f_new, x_new, f_old, x_old):
	if( sum(xnew[0:3])+sum(xnew[9:11])> 1.03 
	or sum(xnew[3:6])+sum(xnew[11:13])< 0.97
	or sum(xnew[3:6])+sum(xnew[11:13])> 1.03
	or sum(xnew[3:6])+sum(xnew[11:13])< 0.97
	or sum(xnew[6:9])+sum(xnew[13:15])> 1.03 
	or sum(xnew[6:9])+sum(xnew[13:15])< 0.97 ):
		#print("rej",xnew)
		return False
		
	else:
		return True	

class RandomDisplacementBounds(object):
	"""random displacement with bounds"""
	def __init__(self, xmin, xmax, stepsize):
		self.xmin = xmin
		self.xmax = xmax
		self.stepsize = stepsize
	
	def __call__(self, x):
		"""take a random step but ensure the new position is within the bounds"""
		#print(sum(x[0:3]),sum(x[3:6]),sum(x[6:9]))
		#print("update")
		if(self.stepsize > 0.5):
			self.stepsize = 0.1
		while True:
			choose =  randint(0,50)
			if (choose==0):
				samp = np.zeros(15)
				for l in range(15):
					samp[l] = uniform(0,1)
				xnew[0:3] = samp[0:3]/sum(samp[0:5])
				xnew[3:6] = samp[5:8]/sum(samp[5:10])
				xnew[6:9] = samp[10:13]/sum(samp[10:15])
				xnew[9:11] = samp[3:5]/sum(samp[0:5])
				xnew[11:13] = samp[8:10]/sum(samp[5:10])
				xnew[13:15] = samp[13:15]/sum(samp[10:15])
				self.stepsize = 0.2
				#print ("new")
			else:
				xnew[:] = x
				#print("accept")
			#print("xnew",xnew)
			region = randint(0,2)
			ak = randint(0,1) 
			if (ak ==0):
				p = randint(0,2)
				pos = region * 3 + p 
			else:
				p = randint(0,1)
				pos = 9 + region * 2 + p
			#print(self.stepsize)	
			s = self.stepsize
			dx = uniform(-s,s)
			xnew[pos] = x[pos] + dx
			#print(pos, x[pos], xnew[pos],dx)
			p = randint(0,2)
			ak = randint(0,1) 
			if (ak ==0):
				p = randint(0,2)
				corr_pos = region * 3 + p 
			else:
				p = randint(0,1)
				corr_pos = 9 + region * 2 + p
			
			xnew[corr_pos] = xnew[corr_pos] -dx
			if (
				xnew[corr_pos] > xmin[corr_pos] 
				and xnew[corr_pos] < xmax[corr_pos] and
			xnew[pos] > xmin[pos] and xnew[pos]<xmax[pos]):
				break

		xfull = complete_rates(xnew)
		k = [a+b for a,b in zip(xfull[0:9],xfull[9:18])]	
		k = np.asarray(k).reshape(3,3)
		k = np.transpose(k)
		Ev, Evec = eigs(k, k=1)
		p = (np.squeeze(Evec) / np.squeeze(Evec).sum()).real

		K = xnew[11] - p[0]/p[1] * xnew[9]
		if(K > 0):
			xnew[1] += xnew[9]
			xnew[3] += p[0] / p[1] * xnew[9]
			xnew[11]-= p[0] / p[1] * xnew[9]
			xnew[9] = xmin[9]
		else:
			xnew[3] += xnew[11]
			xnew[1] += p[1] / p[0] * xnew[11]
			xnew[9]-= p[1] / p[0] * xnew[11]
			xnew[11] = xmin[11]
		#K = p[1]*(x[5]+x[14]) - p[2]*(x[7] + x[16])
		K = xnew[14] - p[1] / p[2] *xnew[12]
		if(K > 0):
			xnew[5] += xnew[12]
			xnew[7] += p[1] / p[2] * xnew[12]
			xnew[14]-= p[1] / p[2] * xnew[12]
			xnew[12] = xmin[12]
		else:
			xnew[7] += xnew[14]
			xnew[5] += p[2] / p[1] * xnew[14]
			xnew[12]-= p[2] / p[1] * xnew[14]
			xnew[14] = xmin[14]
		#print(K, p[1] * (x[5]+x[14]) -p[2] *(x[7]+x[16]))
		#K = p[2]*(x[6]+x[15]) - p[0]*(x[2] + x[11])
		K = xnew[10] - p[2] / p[0] * xnew[13]
		if(K > 0):
			xnew[6] += xnew[13]
			xnew[2] += p[2] / p[0] * xnew[13]
			xnew[10]-= p[2] / p[0] * xnew[13]
			xnew[13] = xmin[13]
		else:
			xnew[2] += xnew[10]
			xnew[6] += p[0] / p[2] * xnew[10]
			xnew[13]-= p[0] / p[2] * xnew[10]
			xnew[10] = xmin[10]
		#print("MC",xnew, s)
		return xnew
	
	

n= [100] *3 # is given by p is EV of pij
c = [15.267, 3.05344, 12.2137, 8.39695, 25.1908, 8.39695, 6.87023, 13.70405, 6.87023]
gamma = [100] * 9
m = [0] *3

xmin_val = 1e-6
#xmin = [0.000001] * 15 #Somewhat random but important
xmin = [xmin_val] *15
xmax = [1] * 15
stepsize = 0.2
bounds = [(low, high) for low, high in zip(xmin, xmax)]

cons = [
lambda x: sum(x[i+0] for i in range(3)) +x[9]+x[10] -  1,
lambda x: sum(x[i+3] for i in range(3))+x[11]+x[12] -  1,
lambda x: sum(x[i+6] for i in range(3))+x[13]+x[14] -  1,
]

tol = 1e-09
eps = 1e-09

minimizer_kwargs = {"method":custmin,"constraints":cons,"bounds":bounds}
#,"options":{"ftol":tol,"eps":eps,"iprint":2}}

likelihood = lambda x: likel(x,-1.0,c,n,gamma,m)

x = np.zeros(15)
xnew = np.zeros(15)

seed(0)
samp = np.zeros(15)
for l in range(15):
	samp[l] = uniform(0,1)
x[0:3] = samp[0:3]/sum(samp[0:4])
x[3:6] = samp[5:8]/sum(samp[5:9])
x[6:9] = samp[10:13]/sum(samp[10:14])
x[9:11] = samp[3:5]/sum(samp[0:4])
x[11:13] = samp[8:10]/sum(samp[5:9])
x[13:15] = samp[13:15]/sum(samp[10:14])
x[10] = xmin_val
x[12] = xmin_val
x[14] = xmin_val

Ev_av = np.zeros(3)
Evec_av = np.zeros((3,3))
T_av = np.zeros((6,3))


for count in [1]:#range(1,2):
	start_time = time.time()
	samp = np.zeros(15)
	for l in range(15):
		samp[l] = uniform(0,1)
	x[0:3] = samp[0:3]/sum(samp[0:4])
	x[3:6] = samp[5:8]/sum(samp[5:9])
	x[6:9] = samp[10:13]/sum(samp[10:14])
	x[9:11] = samp[3:5]/sum(samp[0:4])
	x[11:13] = samp[8:10]/sum(samp[5:9])
	x[13:15] = samp[13:15]/sum(samp[10:14])
	x[10] = xmin_val
	x[12] = xmin_val
	x[14] = xmin_val
	niter = 2
	take_step = RandomDisplacementBounds(xmin, xmax,stepsize)
	result = basinhopping(likelihood, x, minimizer_kwargs=minimizer_kwargs
                      ,take_step=take_step,niter=niter,accept_test=accept_test)
	#print ("init", xu)
	del take_step
	xfull = complete_rates(result.x) 
	#print( likelihood(result.x),niter*k, xfull.reshape(6,3))
	k = [a+b for a,b in zip(xfull[0:9],xfull[9:18])]	
	k = np.asarray(k).reshape(3,3)
	k = np.transpose(k)
	#Ev, Evec = eigs(k,k=2)
	Ev,Evec = np.linalg.eig(k)
	p = (np.squeeze(Evec) / np.squeeze(Evec).sum()).real
	#x[:] = result.x
	Ev_av = (Ev_av * (count-1) + Ev) / count
	Evec_av = (Evec_av * (count-1) + Evec) / count
	T_av = (T_av * (count-1) + xfull.reshape(6,3)) / count

	#print(Ev)
	#print(Evec,Ev)
	#print("sum",sum(k[0:3]))
	#print(likelihood(result.x))
	#print(result)
	#print("\n")
	#print(Ev_av)
	#print(Evec_av)
	#print(Ev_av, Evec_av )

#print(T_av)
#print(Ev_av)
#print(Evec_av)

	#print(sum(c[i]*math.log(xfull[i]+xfull[i+9]) for i in range(9)) 
	#,-sum(n[j] * math.fabs( sum( p[i]*(xfull[i*3+j]+xfull[i*3+j+9]) 
#		for i in range(0,3) )-p[j] ) for j in range(3)) 
#	,-sum(gamma[i*3+j] *math.fabs(p[i]*xfull[i*3+j] - p[j]*xfull[j*3+i]) 
#		for i in range(0,3) for j in range(0,3))
#	,- sum( math.pow(m[j]*(sum(xfull[i+j*3] + xfull[i+j*3+9] for i in range(3)) -  1),2)
#		for j in range(3) )
#	)
	
	#print( sum(xfull[i+0] + xfull[i+9] for i in range(3))
	#	,sum(xfull[i+3] + xfull[i+12] for i in range(3))
	#	,sum(xfull[i+6] + xfull[i+15] for i in range(3))
	#	, p[0] + p[1] + p[2]
	#	)
	#print(p)
#	print("time" , time.time() - start_time)
